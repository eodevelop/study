- 질문 1: 자바의 객체 지향 프로그래밍(OOP) 개념 중 '상속'에 대해 설명해 주세요. '상속'의 장점과 단점을 포함해 주시면    좋겠습니다.
    <details>
    <summary>여기를 클릭하면 답변을 볼 수 있습니다</summary>
    
    - 자바의 객체 지향 프로그래밍(OOP) 개념 중 '상속'에 대해 설명드리겠습니다. 상속은 한 클래스가 다른 클래스의 속성과 메서드를 물려받아 재사용할 수 있도록 하는 기능입니다. 이를 통해 코드의 재사용성을 높이고, 유지보수성을 개선할 수 있습니다.
    
    - 장점 : 
        1. 코드 재사용성: 기존 클래스의 기능을 그대로 사용하면서 필요한 기능을 추가하거나 수정할 수 있습니다. 이를 통해 코드 중복을 줄이고 개발 효율성을 높일 수 있습니다.
        2. 유지보수성 향상: 공통 기능을 상위 클래스에 정의해 두면, 하위 클래스에서 이를 자동으로 상속받아 사용할 수 있어 유지보수가 용이합니다. 상위 클래스의 기능을 수정하면, 이를 상속받은 모든 하위 클래스에 자동으로 적용됩니다.
        3. 유연한 설계: 상속을 통해 클래스 간의 계층 구조를 만들 수 있어, 시스템을 유연하게 설계할 수 있습니다.
    
    - 단점:
        1. 단일 상속: 자바는 단일 상속만을 지원합니다. 즉, 한 클래스는 하나의 부모 클래스만 가질 수 있습니다. 이로 인해 다중 상속이 필요한 경우에는 인터페이스를 사용해야 합니다.
        2. 강한 결합: 상속을 남용하면, 상위 클래스와 하위 클래스 간의 결합도가 높아져, 변경에 취약해질 수 있습니다. 상위 클래스의 변경이 하위 클래스에 영향을 미칠 수 있기 때문에, 상속 구조를 설계할 때 신중해야 합니다.
        3. 복잡성 증가: 상속 계층이 깊어지면, 시스템의 복잡성이 증가할 수 있습니다. 이는 코드를 이해하고 디버깅하는 데 어려움을 초래할 수 있습니다.
    </details>
    <br/>
    <br/>

- 질문 2: 자바에서 final 키워드의 용도에 대해 설명해 주세요. 클래스, 메서드, 변수에 각각 final을 사용하면 어떤 의미가 있는지 예를 들어 설명해 주세요.
    <details>
    <summary>여기를 클릭하면 답변을 볼 수 있습니다</summary>
   
    - final 키워드는 자바에서 변경할 수 없다는 의미를 가지며, 클래스, 메서드, 변수에 각각 다르게 적용될 수 있습니다.
        
        - 변수에서 사용 시 : 변수를 final로 선언하면, 해당 변수의 값을 한 번 초기화한 후 변경할 수 없습니다. 즉, 상수로 사용할 수 있습니다.
        - 메소드에서 사용 시 : 메서드를 final로 선언하면, 그 메서드는 하위 클래스에서 오버라이드할 수 없습니다. 이를 통해 메서드의 구현을 변경하지 못하도록 할 수 있습니다.
        - 클래스에서 사용 시 : 클래스를 final로 선언하면, 그 클래스는 다른 클래스가 상속할 수 없습니다. 이를 통해 클래스의 구조를 변경하지 못하도록 할 수 있습니다. 
    </details>
    <br/>
    <br/>

- 질문 3: 자바에서 예외 처리(Exception Handling)에 대해 설명해 주세요. try, catch, finally 블록의 역할과 throw 및 throws 키워드의 차이를 설명해 주세요.
    <details>
    <summary>여기를 클릭하면 답변을 볼 수 있습니다</summary>

    - 자바에서 예외 처리(Exception Handling)는 프로그램 실행 중 발생할 수 있는 예외 상황을 적절히 처리하여 프로그램이 비정상적으로 종료되지 않도록 하는 방법입니다. 예외 처리는 try, catch, finally 블록과 throw, throws 키워드를 사용하여 구현할 수 있습니다.
        - try 블록:  예외가 발생할 수 있는 코드를 감싸는 블록입니다. try 블록 내에서 예외가 발생하면, 해당 예외를 처리하기 위해 catch 블록으로 제어가 이동합니다.
        - catch 블록:  try 블록에서 발생한 특정 예외를 처리하는 블록입니다. 예외 유형에 따라 여러 개의 catch 블록을 사용할 수 있습니다.
        - finally 블록: 예외 발생 여부와 관계없이 항상 실행되는 블록입니다. 주로 자원 해제 작업에 사용됩니다.
        - throw 키워드: 예외를 강제로 발생시키는 키워드입니다. 사용자 정의 예외를 생성하거나 특정 상황에서 예외를 발생시킬 때 사용됩니다.
        - throws 키워드: 메서드 선언부에 사용되어 해당 메서드가 발생시킬 수 있는 예외를 명시합니다. 호출자에게 예외가 발생할 수 있음을 알리는 역할을 합니다.
    </details>
    <br/>
    <br/>

- 질문4 : 자바의 메모리 관리에 대해 설명해 주세요. JVM의 메모리 구조와 각 영역의 역할을 상세히 설명하고, 가비지 컬렉션이 어떻게 동작하는지 설명해 주세요.
    <details>
    <summary>여기를 클릭하면 답변을 볼 수 있습니다</summary>
    
    - 자바의 메모리 관리는 JVM(Java Virtual Machine)에 의해 수행됩니다. JVM의 메모리 구조는 크게 여러 영역으로 나뉩니다.

    - 메소드 영역 (Method Area)
        - 클래스에 대한 메타데이터, 상수, static 변수, 메서드 코드 등을 저장합니다.
        - 모든 스레드가 공유하는 영역입니다.
    
    - 힙 영역 (Heap Area)
        - 모든 객체와 배열이 저장되는 곳입니다.
        - 모든 스레드가 공유하는 영역입니다.
        - 가비지 컬렉션의 주요 대상입니다.
    
    - 스택 영역 (Stack Area)
        - 각 스레드마다 별도로 존재하며, 메서드 호출 시 생성되는 지역 변수, 매개 변수, 리턴 값 등을 저장합니다.
        - 메서드 호출 시마다 프레임이 생성되고, 메서드가 종료되면 해당 프레임이 제거됩니다.
    
    - PC 레지스터 (Program Counter Register)
        - 현재 실행 중인 JVM 명령의 주소를 가리킵니다.
        - 각 스레드마다 별도로 존재합니다.
    
    - 네이티브 메소드 스택 (Native Method Stack)
        - 자바 외부의 네이티브 코드를 실행할 때 사용됩니다.
    
    - 가비지 컬렉션 (Garbage Collection)
        - 자바는 자동 메모리 관리를 위해 가비지 컬렉션을 사용합니다. 이는 더 이상 참조되지 않는 객체를 자동으로 메모리에서 해제하는 과정입니다.
        - Mark and Sweep Algorithm: 객체가 사용 중인지 확인(marking)하고, 사용되지 않는 객체를 메모리에서 제거(sweeping)하는 방식입니다.
        - Generational Garbage Collection: 객체의 생애주기를 고려하여, Young Generation과 Old Generation으로 나누어 가비지 컬렉션을 최적화합니다.
        - Young Generation: 새로 생성된 객체가 할당되는 공간으로, 여기서 살아남은 객체는 Old Generation으로 이동합니다.
        - Old Generation: Young Generation에서 살아남은 객체가 이동하는 공간으로, 주기적으로 가비지 컬렉션이 수행됩니다.
        - Minor GC: Young Generation에서 발생하는 가비지 컬렉션입니다. 빈번하게 발생하지만, 시간이 짧습니다.
        - Major GC (Full GC): Old Generation과 Young Generation을 모두 포함하여 발생하는 가비지 컬렉션입니다. 드물게 발생하지만, 시간이 더 오래 걸립니다.
    </details>
    <br/>
    <br/>

- 질문5 : 자바에서 동기화(synchronization)란 무엇인가요? synchronized 키워드의 사용 방법과 volatile 키워드의 역할에 대해 설명해 주세요. 또한, synchronized 블록과 ReentrantLock의 차이점에 대해 설명해 주세요.
    <details>
    <summary>여기를 클릭하면 답변을 볼 수 있습니다</summary>

    - 동기화란 : 동기화는 멀티 스레드 환경에서 동시에 접근 가능한 공유 자원의 일관성을 유지하기 위해 사용됩니다.
    - synchronized 키워드
        - 메소드와 블럭 단위로 사용되며 해당 키워드가 들어있는 겨우 한 스레드만 접근이 가능합니다.
    - volatile 키워드
        - CPU 캐시가 아닌 메인 메모리에 직접 읽고 쓰여지게 하여, 여러 스레드에 의해 읽고 쓰여지는 변수의 일관성을 보장합니다.
    - synchronized 블록과 ReentrantLock의 차이점
        - synchronized 블록은 JVM에 의해 제공되는 키워드로, 자동으로 lock을 획득하고 해제합니다. 반면 ReentrantLock은 java.util.concurrent 패키지에 있는 클래스로, lock을 직접 획득하고 해제해야 합니다. ReentrantLock은 더 세밀한 제어가 가능하고, 조건 변수를 사용할 수 있습니다.
    </details>
    <br/>
    <br/>



    <details>
    <summary>여기를 클릭하면 답변을 볼 수 있습니다</summary>
    </details>
    <br/>
    <br/>


    <details>
    <summary>여기를 클릭하면 답변을 볼 수 있습니다</summary>
    </details>
    <br/>
    <br/>
